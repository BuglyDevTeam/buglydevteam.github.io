<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Bugly技术团队博客</title>
  <subtitle>一种愉悦的开发方式</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://buglydevteam.github.io/"/>
  <updated>2017-05-15T09:59:13.000Z</updated>
  <id>https://buglydevteam.github.io/</id>
  
  <author>
    <name>Bugly</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Bugly多渠道热更新解决方案</title>
    <link href="https://buglydevteam.github.io/2017/05/15/solution-of-multiple-channel-hotpatch/"/>
    <id>https://buglydevteam.github.io/2017/05/15/solution-of-multiple-channel-hotpatch/</id>
    <published>2017-05-15T09:47:04.000Z</published>
    <updated>2017-05-15T09:59:13.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Gradle使用productFlavors打渠道包的痛"><a href="#Gradle使用productFlavors打渠道包的痛" class="headerlink" title="Gradle使用productFlavors打渠道包的痛"></a>Gradle使用productFlavors打渠道包的痛</h2><p>有很多同学可能会采用配置productFlavors来打渠道包，主要是它是原生支持，方便开发者输出不同定制版本的apk，举个例子：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">android &#123;</div><div class="line">    ...</div><div class="line"></div><div class="line">    defaultConfig &#123;</div><div class="line">        minSdkVersion 8</div><div class="line">        versionCode 10</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    productFlavors &#123;</div><div class="line">        flavor1 &#123;</div><div class="line">            packageName "com.example.flavor1"</div><div class="line">            versionCode 20</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        flavor2 &#123;</div><div class="line">            packageName "com.example.flavor2"</div><div class="line">            minSdkVersion 14</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样就可以输出两个定制的apk，不同包名，版本号也不同。 但是，如果用它来打渠道包是一个非常低效的做法，因为它每一次都会走编译流程，你想一下如果每打一个渠道包就要走一下编译流程，100个渠道包那得多慢。</p>
<p>那如果你能忍受这么低效打渠道包的方式，那回到本文焦点，我先问个问题：“如果你要针对多渠道进行打补丁，你应该怎么做？”</p>
<p>你可能会回答，那就针对不同的渠道包进行打补丁。没错，这个确实行得通，Bugly也是支持以这种方式进行打补丁，tinker-support插件会为不同渠道包插入不同的TINKER_ID, 唯一标识当前版本的渠道包，我们可以看下gradle打多渠道补丁的配置（详细参考<a href="https://bugly.qq.com/docs/user-guide/instruction-manual-android-hotfix-demo/?v=20170512172046#_3" title="多渠道热更新" target="_blank" rel="external">多渠道热更新</a>）：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/2017-05-15/Snip20170209_12.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/2017-05-15/Snip20170209_13.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>上面的示例只是配置了两个渠道，如果你配置超过5个的话，那么就意味着你要一个补丁，一个补丁上传到Bugly补丁管理后台，况且我们也只允许同时下发5个版本的补丁。这里提一下为什么要上传所有渠道的补丁，因为通过productFlavors配置，会修改buildConfig类中的FLAVOR字段，这会导致生成的不同渠道包的dex是不一样的，所以只能针对具体渠道进行打补丁。这就非常的尴尬了，那怎么办呢？有没有版本通过一个补丁就能够修复所有渠道，答案是：<strong>有的，但前提是你要保证所有渠道包代码是一致的</strong>。</p>
<h2 id="通过多渠道打包框架快速打多渠道包"><a href="#通过多渠道打包框架快速打多渠道包" class="headerlink" title="通过多渠道打包框架快速打多渠道包"></a>通过多渠道打包框架快速打多渠道包</h2><blockquote>
<p>这里推荐使用<a href="https://github.com/Meituan-Dianping/walle" title="walle" target="_blank" rel="external">walle</a>来打多渠道包，新一代多渠道打包神器。</p>
</blockquote>
<p>通过walle或者类似的打包工具就不会改变dex的结构，只是修改<strong>APK Signature Block</strong>来添加自定义的渠道信息来生成渠道包。</p>
<p>配置示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 多渠道使用walle示例（注：多渠道使用）</div><div class="line">apply from: &apos;multiple-channel.gradle&apos;</div></pre></td></tr></table></figure>
<p>创建multiple-channel.gradle，内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">apply plugin: &apos;walle&apos;</div><div class="line"></div><div class="line">walle &#123;</div><div class="line">    // 指定渠道包的输出路径</div><div class="line">    apkOutputFolder = new File(&quot;$&#123;project.buildDir&#125;/outputs/channels&quot;);</div><div class="line">    // 定制渠道包的APK的文件名称</div><div class="line">    apkFileNameFormat = &apos;$&#123;appName&#125;-$&#123;packageName&#125;-$&#123;channel&#125;-$&#123;buildType&#125;-v$&#123;versionName&#125;-$&#123;versionCode&#125;-$&#123;buildTime&#125;.apk&apos;;</div><div class="line">    // 渠道配置文件</div><div class="line">    channelFile = new File(&quot;$&#123;project.getProjectDir()&#125;/channel&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>创建channel配置:</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/2017-05-15/Snip20170515_48.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>命令行打多渠道包：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./gradlew clean assembleReleaseChannels</div></pre></td></tr></table></figure>
<p>输出结果如下：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/2017-05-15/Snip20170515_49.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>ok，到此已经实现快速打多渠道包了。</p>
<h2 id="如何获取渠道信息？"><a href="#如何获取渠道信息？" class="headerlink" title="如何获取渠道信息？"></a>如何获取渠道信息？</h2><p>如果你想获取渠道信息进行一些统计的分析，可以按照以下方式（具体参考<a href="https://github.com/Meituan-Dianping/walle" title="walle" target="_blank" rel="external">walle</a>)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">dependencies &#123;</div><div class="line">    compile &apos;com.meituan.android.walle:library:1.1.3&apos;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在代码中获取渠道信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">String channel = WalleChannelReader.getChannel(this.getApplicationContext());</div></pre></td></tr></table></figure>
<p>如果你已经集成了<strong>Bugly的异常上报</strong>，你就可以通过以下方式来塞入渠道信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">String channel = WalleChannelReader.getChannel(getApplication());</div><div class="line">Bugly.setAppChannel(getApplication(), channel);</div><div class="line"> // 这里实现SDK初始化，appId替换成你的在Bugly平台申请的appId</div><div class="line">Bugly.init(getApplication(), &quot;YOUR_APP_ID&quot;, true);</div></pre></td></tr></table></figure>
<p>这样我们就可以按渠道维度来统计你们app的Crash数据了。</p>
<h2 id="一个补丁修复所有渠道"><a href="#一个补丁修复所有渠道" class="headerlink" title="一个补丁修复所有渠道"></a>一个补丁修复所有渠道</h2><p>重头戏，总是留在最后。 在打渠道包的过程，因为会走编译流程，热更新插件也会在bakApk生成对应的基线版本，这个跟普通打包就没有差别了：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/2017-05-15/Snip20170515_52.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>只需要上传补丁包到补丁管理后台，然后下发即可。</p>
<p>笔者随便挑了三个渠道分别安装到不同设备，均成功打上补丁：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/2017-05-15/Snip20170515_53.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>ok，基本上我们的需求就已经实现啦，妈妈再也不用担心我加班加点上传补丁包了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Bugly目前同时支持两种方式进行渠道包的热更新：</p>
<ul>
<li>productFlavors方式打多渠道包</li>
<li>快速打渠道包工具（Gradle）</li>
</ul>
<p>笔者是推荐使用第二种方式，不仅能够快速打包，也能够轻松实现一个补丁修复所有渠道。</p>
<p>如果大家对以上有什么疑问的话，可以在下面留言，我们共同探讨下。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Gradle使用productFlavors打渠道包的痛&quot;&gt;&lt;a href=&quot;#Gradle使用productFlavors打渠道包的痛&quot; class=&quot;headerlink&quot; title=&quot;Gradle使用productFlavors打渠道包的痛&quot;&gt;&lt;/a&gt;Gr
    
    </summary>
    
      <category term="Android" scheme="https://buglydevteam.github.io/categories/Android/"/>
    
    
      <category term="热更新" scheme="https://buglydevteam.github.io/tags/%E7%83%AD%E6%9B%B4%E6%96%B0/"/>
    
      <category term="多渠道" scheme="https://buglydevteam.github.io/tags/%E5%A4%9A%E6%B8%A0%E9%81%93/"/>
    
  </entry>
  
  <entry>
    <title>谈谈程序员的焦虑感</title>
    <link href="https://buglydevteam.github.io/2017/04/30/talk-about-the-anxious-of-programmer/"/>
    <id>https://buglydevteam.github.io/2017/04/30/talk-about-the-anxious-of-programmer/</id>
    <published>2017-04-30T07:11:41.000Z</published>
    <updated>2017-05-15T09:48:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章继续不谈技术，我们来谈谈关于程序员的焦虑感，写这篇文章源自有位同学问了我一个问题：</p>
<blockquote>
<p>我接触Android 应用层也快3,4年了，说实话，公司一直让做app 层开发，工作之余，学完ReactNative 和Weex，简单的做了Demo，实际开发中不让上，学完一年忘完了，之前大学专业还专门学了一年Linux 内核，开发中很少去用，慢慢就废了。有公司前辈建议我学java后端 ，有前辈建议我去学混合开发，说实话，好迷茫，尤其是偶尔学的新东西，如果成为不了一种知识体系，很碎片化的在学习，跟我这样，学了一个月的node.js，学完没处上，慢慢就发现，不知道学啥了。</p>
</blockquote>
<p>我一看，这不是我曾经迷茫过的类似的问题么。我相信这也是工作几年的程序员会产生的迷茫，因为工作的几年已经不是那时刚步入社会的新人（菜鸟），已经可以做一些曾经做不了的事情了，也算是个熟练工了，能够自己解决日常工作的一些问题，能够比较轻松实现一些功能需求了。但是现在问题来了，技术到了瓶颈，怎么办？我曾经在知乎回答过一个问题：</p>
<blockquote>
<p><a href="https://www.zhihu.com/question/29708440/answer/96146770" target="_blank" rel="external">感觉安卓应用开发就是一些接口的调用和ui界面的逻辑处理，还有其他可以深入学习的吗？</a> - 来自知乎</p>
</blockquote>
<p>当时我的回答是这样的：</p>
<blockquote>
<p>独立开发过几个产品，说一下自己的见解，基本上有完整经历过一个产品的开发过程都应该清楚UI层是应用开发中最常变的一部分，app开发者绝大部分的时间都花在UI微调上，而业务逻辑基本上需求定下来不会变动太多，除非是产品迭代一些功能性的追加，不然就是不停的堆UI、堆UI，干过两年以上的开发者基本的开发能力已经有了，业务能力也差不多，这时候会遇到瓶颈，基本上就是找不到更加深入的方向，这个时候就可以考虑一下自己参与过的产品所使用到的技术是自己深究过的，打个比方，开发app的时候，一般会用到Http框架，这样的框架你是否有真正去实践过，或者有研究过它的实现思路和设计思想，我们一般都会拿过来用，但为什么要这样设计就是我们需要去了解的，这可以提高你的架构的设计能力和编码的水平，除了框架，更多的是深入framework层相关的，一些特殊的需求，比如动态热更新、插件化的实现，对应用开发者来说都是新的挑战，还有对app的性能调优，产品上的优化，这些东西都是可以根据其中某一个点进行发散的。只做UI层的尝试是没有什么前途的，不管干多少年，眼界也是极其有限，做技术的只能不停的深挖，构建完整的知识体系，才能打通自己的任督二脉。我个人的一些观点，仅供参考。</p>
</blockquote>
<p>这个只是针对App开发的一些见解罢了。想一想，现在技术日新月异，层出不穷， 就拿<strong>Android领域</strong>来说：</p>
<blockquote>
<p>RxJava、Kotlin、React native、MVP、MVVM、插件化、热更新、Data Binding…</p>
</blockquote>
<p>这些技术的出现都是为了去解决以往解决不了的问题，那么我们的问题来了，我们是不是每出一个新技术都要去学一下，当然我们作为程序员也应该与时俱进，去接受一些先进的思想。但这里有个问题就是，我们太过于强调新，而忘记了这些新技术的本质，任何一门新的技术都改不了一个事实：<strong>底层技术是不会变的</strong>。至于学不学，可以问自己一个问题：</p>
<blockquote>
<p>学这门技术能够解决什么问题？我如何在实际工作中运用上？</p>
</blockquote>
<p>我们学习一门新的技术不是为了学习而学，最终还是要回归实际应用上去，不然过一段时间你发现自己又给忘记了，不然怎么叫<strong>学以致用</strong>呢。</p>
<p>前面的问题还有一个就是，<strong>要往哪个方向学更有前景</strong>？这个真不好说，很多人经常犯的一个毛病就是<strong>想得太多，做得太少</strong>，每天都在纠结学什么，就是不动手。我们可以看到是前几年移动开发很火，大家一股脑的就往这个领域钻，再看看现在，移动开发似乎没有这么火了，想找工作的同学和想换工作的同学是不是发现难很多了，你能想到会是这样的局面吗，真不好说，现在也许是市场冷静了，任何一门领域的火热都跟市场的需求相挂钩，一旦市场需求量少了，或者不再需要，我们都有可能面临失业。</p>
<p>我们来看看现在什么最火热，列举一些：</p>
<blockquote>
<p>VR、AR、机器学习、深度学习、人工智能</p>
</blockquote>
<p>想必大家每天都会看到这些相关的新闻和资讯，也许这些是未来比较有前景的领域了，但我们不能因为这些概念的火热就一股脑得投入到里面，我的看法就是找一个自己感兴趣的方向，持续发力，让自己成为这领域的专家，但前提是你得打好基础。</p>
<p>好了，说到这里你的焦虑感是否少了些许呢？如果还没有，我提个问题就是你想成为哪个领域的工程师：</p>
<ul>
<li>终端<ul>
<li>Android/iOS</li>
<li>Cocos2d</li>
<li>Unity 3D</li>
</ul>
</li>
<li>Web前端</li>
<li>后台</li>
<li>运维</li>
<li>测试</li>
</ul>
<p>其实每个领域都有相应的技术栈，你可以从中选一个自己感兴趣的方向去学习，但并不局限于说你只关注于某一个方向，我的建议是：</p>
<blockquote>
<p>专注于一个领域，横向扩展其他领域的技术。</p>
</blockquote>
<p>总之一句话，<strong>不要自我设限，没有人说你一定要成为什么样的人，而是你想成为什么样的人</strong>。谁知道哪天你不想做程序员了，想回家卖咸鸭蛋了，那你就不需要纠结学什么的问题了，及时行乐，开心就好。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章继续不谈技术，我们来谈谈关于程序员的焦虑感，写这篇文章源自有位同学问了我一个问题：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;我接触Android 应用层也快3,4年了，说实话，公司一直让做app 层开发，工作之余，学完ReactNative 和Weex，简单的做了D
    
    </summary>
    
      <category term="技术分享" scheme="https://buglydevteam.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="技术感悟" scheme="https://buglydevteam.github.io/tags/%E6%8A%80%E6%9C%AF%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
  <entry>
    <title>谈谈程序员解决问题的能力</title>
    <link href="https://buglydevteam.github.io/2017/04/30/talk-about-slove-problem-skill-of-programmer/"/>
    <id>https://buglydevteam.github.io/2017/04/30/talk-about-slove-problem-skill-of-programmer/</id>
    <published>2017-04-30T07:04:56.000Z</published>
    <updated>2017-04-30T07:07:28.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>解决问题的能力，程序员立业之本。</p>
</blockquote>
<p>一般写文章我不会特意去写，而是有感而发的时候刚好又有时间我就会去写写文字。本想推些技术文章的，但写技术文章又很耗时，写得太浅显又没有技术含量，写多了恐怕大家也没耐心去看（不就是懒么，给自己找这么多借口）。公众号这么多，你又能看的了多少呢？小巫这个公众号不会像某些网红那样每天都想破脑袋去写文章，也不期望这个公众号能给我带来什么，毕竟以我的尿性我让我每天写鸡汤文我自己都会恶心。好了，进入今天这篇文章的主题，跟大家谈谈程序员解决问题的能力。</p>
<h3 id="为什么会想写这篇文章？"><a href="#为什么会想写这篇文章？" class="headerlink" title="为什么会想写这篇文章？"></a>为什么会想写这篇文章？</h3><p>前面我写过一篇关于独立思考的文章-<a href="http://www.jianshu.com/p/e698fea61a39" target="_blank" rel="external">你是怎么思考的？</a>[1]，大家感兴趣可以去看下。关于独立思考，我觉得每个人都应该要有，作为一个成年人，很多事情都要别人讲得很明白才懂得怎么去做，那别人也不太愿意把事情交给你办，也不太相信你能办好，你也很难掌控自己的命运。今天的这个主题虽然讲的是程序员解决问题的能力，其实也还是讲独立思考的能力，因为解决问题的能力也是源自你是否会独立思考。之前写过一些文章，有的同学想让我写写在鹅厂的一些经验，其实说真的，在鹅厂工作也是因人而异的，不管在哪里工作最终还是取决于你是怎么赋予工作的意义，每天纠结自己工作重复繁重，纠结工作技能得不到提升，纠结薪水满足不了自己的欲望，纠结这纠结那是毫无意义的。问题的根本也不在于这些，而是你是否足够沉得住气去提升自己。如果你连日常工作的一些问题都解决不好，你也别期望自己能在很短的时间内提升很高的水平。还是那句话，就算你有十年的工作经验，如果你只是一年的工作经验用了十年，那真的怪不得别人比你厉害了，人到中年的时候那真的有危机了。</p>
<h3 id="吐槽一些开发者白纸一般的脑袋"><a href="#吐槽一些开发者白纸一般的脑袋" class="headerlink" title="吐槽一些开发者白纸一般的脑袋"></a>吐槽一些开发者白纸一般的脑袋</h3><p>之从做了SDK开发者之后，每天帮助用户解决各种各样的问题，那我真的有理由相信为什么国外的月亮会比国内的月亮圆了，因为国内的一些开发者真的让我很方啊。国内的开发者复制黏贴的能力是一流的，嗖得一声就能把功能实现，感觉好厉害的样子（皮皮虾，我们走）。集成我们提供的SDK的时候，也是嗖的一声遇到问题不知道怎么解决。</p>
<blockquote>
<p>小白开发者A：为什么升级弹窗提示不了？我已经完全按照文档集成了啊，求救啊。。<br>小白开发者B：为什么集成热更新SDK之后，修复不了我的问题？<br>小白开发者C：集成SDK之后，编译出错了，谁能帮忙看下。<br>小白开发者D：怎么开启混淆啊。。。<br>小白开发者E：为什么没有mapping文件。<br>小白开发者F：为什么接入SDK之后，没有看到log。<br>小白开发者G：这个异常怎么解决？<br>更多。。。</p>
</blockquote>
<p>虽然标注的是小白开发者，但我也遇到很多工作好几年的开发者同样这样问问题，这个已经不是经验上的的问题了。换个角度思考一下，如果别人向你这样问问题，你会理睬他么，说真的我还不如利用这些时间多修几个bug，很多开发群最终都会沦为水群就是这个道理。大家都有当小白的经历，人生这一辈子不懂的事情太多了，那你总不能让别人牵着你走，作为一个程序员要对得起程序员这个称号，作为一个工程师，你是否能体现自己工程方面的能力。如果连基本的解决问题的能力都没有，那还是尽快放弃当程序员，这一行当没你想得这么好玩。</p>
<h3 id="怎样才算具备解决问题的能力"><a href="#怎样才算具备解决问题的能力" class="headerlink" title="怎样才算具备解决问题的能力"></a>怎样才算具备解决问题的能力</h3><blockquote>
<p>我先说一下我的一家之言吧，说这些并不是为了吹嘘自己能力有多强，只是把我看到的和想到的东西用文字说出来，至于别人怎么去解读我是无所谓的。</p>
</blockquote>
<h4 id="第一点：主动尝试解决问题"><a href="#第一点：主动尝试解决问题" class="headerlink" title="第一点：主动尝试解决问题"></a>第一点：主动尝试解决问题</h4><p>程序员的解决问题能力不是天生的，自然得靠后天的经验积累。我们工作中会遇到各种各样的问题，比如需要去跟踪调试产品所产生的bug，又比如说使用第三方组件所遇到的一些问题，再比如说使用一些插件或者IDE所产生的一些编译问题。这个时候第一反应不是去别人那里寻求帮助，而是自己尝试去看去解决问题。首先得确定这是一个什么样的问题，对这个问题下一个定义，看它是自己编码上的问题，还是一些编译上的问题，再或者是第三方库引入的问题。确定之后，你可以根据运行时产生的崩溃信息或者编译时出现的编译错误，找到错误的根源。如果是<strong>代码上的问题</strong>其实是很好定位的，我们只需要根据错误的堆栈找到出错的地方，然后你再去看这部分代码的处理逻辑，只要不是特别复杂的业务处理，基本上能很快解决。如果是<strong>编译时出的问题</strong>怎么办？你先看具体的编译错误是什么，看自己以前是否有遇到过，是否能够确定是什么环节导致的编译错误，比如是开发环境版本问题，或者是插件的版本问题，又或者是代码导致的编译问题，这类问题只要逐个排除相信也能够轻松解决。那如果是<strong>业务逻辑导致的问题</strong>怎么办？那我就建议你自己根据需求重新梳理清楚业务逻辑，可以通过debug来验证你的结果，又或者可以通过日常写<strong>单元测试用例</strong>来保证业务逻辑的正确性。关于各类问题的解决，解决办法总是能找到，就看你是否足够耐心去寻求解决方案。</p>
<h4 id="第二点：学会提问"><a href="#第二点：学会提问" class="headerlink" title="第二点：学会提问"></a>第二点：学会提问</h4><p>刚才说的第一点，对开发者能力有一定的要求，并不是所有开发者都能够做到这一点，那如果依靠自身能力解决不了问题该怎么办？没错，就是向别人提问，但这里要注意一下提问的技巧，就不要像我所吐槽的白纸一般的开发者。关于提问的技巧很多人都在提，感同身受最深的应该是那些为开源项目做贡献的开发者了，只要一开源就必定会有很多人过来问问题，提issue。以我作为SDK开发者来说，我希望开发者这样向我提问：</p>
<blockquote>
<ol>
<li>首先态度诚恳，平等尊重（这很重要）</li>
<li>问题标题有针对性<br> 标题指明环境、错误时机、现象。如：<br> 较差的标题（×）：发现一个兼容性bug（太宽泛，完全没有点进来看的欲望）<br> 较好的标题（√）：Vivo X5上xxx SDK调用初始化时导致崩溃的兼容性问题求解</li>
<li>问题描述详细<br> 问题描述详细，可以方便其他用户帮您定位问题。尽量提供详细的环境、错误时机、堆栈、日志、现象、截图等等。<br> 可以参考如下格式：<br>【问题描述】<br> 描述出现问题的环境：Android版本、设备型号、网络状态、SDK版本等等<br> 描述为了解决问题作出的一些尝试，例如Google查到的相关资料<br>【错误堆栈】<br> 贴出由Bugly分享出来的错误堆栈（分享链或截图）    </li>
</ol>
</blockquote>
<p>这里有一篇文章也推荐大家看下- <a href="https://github.com/tvvocold/How-To-Ask-Questions-The-Smart-Way" target="_blank" rel="external">提问的智慧</a>[2]，想提高自己解决问题的能力，首先得学会如何提问。</p>
<h4 id="第三点：经验总结"><a href="#第三点：经验总结" class="headerlink" title="第三点：经验总结"></a>第三点：经验总结</h4><p>我们日常遇到的问题就类似打怪升级一样，你解决的问题越多你的能力就会越强，经验自然也会越来越丰富。但人的脑袋不可能记住所有事情，将自己遇到的问题沉淀下来对以后自己查阅也有很大的帮助，就不必每次都要去Google，自己也能够有一个索引库。经常自己总结，也能够提高自己的写作能力，以后写文章、ppt总结提炼自然也难不倒你了，也是一举两得的事情。还有你以后求职面试过程中，提及自己这方面的能力的时候，也能够为自己面试加分哦。</p>
<h4 id="第四点：知识经验传承"><a href="#第四点：知识经验传承" class="headerlink" title="第四点：知识经验传承"></a>第四点：知识经验传承</h4><blockquote>
<p>精神哥说过：不总结哪来的经验，不分享经验有何用？</p>
</blockquote>
<p>一个人能产生多大价值取决于他的影响力有多大，之前看到有人在我们内部论坛提问说提高影响力有什么用？你看看马云就能知道有什么用了，他说一句话比你说上百句都管用，毕竟人家的影响力在那里。很多微商都经常拿马云来说话，尽管马云自身没说过这些话，但为什么别人拿马云来忽悠人，不拿你来忽悠人，这就是影响力的作用。我们程序员做知识经验的传承，不仅能够提高你自身的影响力，还能够帮助你提升逻辑思维能力，因为你需要去总结提炼，你需要将问题梳理清楚，并且要将知识点描述得能够让别人更容易接受。你的经验虽然是你自己的，但如果你的经验能够帮助到别人，那你的价值就不一样了。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>笔者在写开发文档的时候，经常都会去思考怎么让开发者通过这个文档更加轻松的接入我们SDK，怎么样设计接口会更符合开发者的思维，多提几个为什么可以帮助自己让自己的思考更加完善，这篇文章是笔者入行这两三年的一些思考，也希望能够帮助到广大开发者能够清晰认识到自己在这方面的能力，最后谢谢大家能够看到这里。</p>
<p>[1] . <a href="http://www.jianshu.com/p/e698fea61a39" target="_blank" rel="external">http://www.jianshu.com/p/e698fea61a39</a><br>[2]. <a href="https://github.com/tvvocold/How-To-Ask-Questions-The-Smart-Way" target="_blank" rel="external">https://github.com/tvvocold/How-To-Ask-Questions-The-Smart-Way</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;解决问题的能力，程序员立业之本。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一般写文章我不会特意去写，而是有感而发的时候刚好又有时间我就会去写写文字。本想推些技术文章的，但写技术文章又很耗时，写得太浅显又没有技术含量，写多了恐怕大家也没耐心去看（不
    
    </summary>
    
    
      <category term="技术感悟" scheme="https://buglydevteam.github.io/tags/%E6%8A%80%E6%9C%AF%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
  <entry>
    <title>Git工作流的一些经验分享</title>
    <link href="https://buglydevteam.github.io/2017/02/23/share-the-experiences-of-git-workflow/"/>
    <id>https://buglydevteam.github.io/2017/02/23/share-the-experiences-of-git-workflow/</id>
    <published>2017-02-23T09:10:21.000Z</published>
    <updated>2017-02-23T09:36:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>笔者使用git有一段时间了，踩过不少坑，这里分享下我在git工作流方面的一些经验。</p>
<h2 id="什么是Git工作流？"><a href="#什么是Git工作流？" class="headerlink" title="什么是Git工作流？"></a>什么是Git工作流？</h2><p>Git工作流你可以理解为工作中团队成员遵守的一种代码管理方案，在Git中有以下几种工作流方案作为方案指导：</p>
<ul>
<li>集中式工作流</li>
<li>功能开发工作流</li>
<li>Gitflow工作流</li>
<li>Forking工作流</li>
</ul>
<p>下面针对性说下每个工作流可能使用到的场景和适用性：</p>
<p><strong>集中式工作流</strong></p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/2017-02-23/1487161222036.png" alt="集中式工作流" title="">
                </div>
                <div class="image-caption">集中式工作流</div>
            </figure>
<p>这种工作方式跟svn类似，它只有一个master分支，开发者会先把远程的仓库克隆到本地，之后的修改和提交都在本地操作，直到在某个合适的时间点将本地的代码合入到远程master。这种工作流比较<strong>适合小团队</strong>，因为小团队可能不会太多的协作和合流的动作。</p>
<p><strong>功能开发工作流</strong></p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/2017-02-23/1487170001879.png" alt="功能开发工作流" title="">
                </div>
                <div class="image-caption">功能开发工作流</div>
            </figure>
<p>这种工作流关注功能开发，不直接往master提交代码保证它是稳定并且干净的，而是从master拉取feature分支进行功能开发，团队成员根据分工拉取不同的功能分支来进行不同的功能开发，这样就可以完全隔离开每个人的工作。当功能开发完成后，会向master分支发起Pull Request，只有审核通过的代码才真正允许合入master，这样就加强了团队成员之间的代码交流，也就是我们常说的Code Review。</p>
<p><strong>Gitflow工作流</strong></p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/2017-02-23/1487170152978.png" alt="Gitflow工作流" title="">
                </div>
                <div class="image-caption">Gitflow工作流</div>
            </figure>
<p>这个工作流其实也是我们团队采用的工作流，这也是很多团队会采用的工作流，它会相对复杂一点，但它非常适合用来管理大型项目的发布和维护，后面笔者也会详细讲下这一块。贯穿整个开发周期，master和develop分支是一直存在的，master分支可以被视为稳定的分支，而develop分支是相对稳定的分支，特性开发会在feature分支上进行，发布会在release分支上进行，而bug修复则会在hotfix分支上进行。笔者也是花了不少时间才熟练掌握整个工作流，期间遇到不少坑，后面会跟大家分享下。</p>
<p><strong>Forking工作流</strong></p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/2017-02-23/1487171732444.png" alt="Forking工作流" title="">
                </div>
                <div class="image-caption">Forking工作流</div>
            </figure>
<p>Forking工作流对于开源项目贡献者一定不陌生了，它有一个公开的中央仓库，其他贡献者可以Fork（克隆）这个仓库作为你自己的私有仓库，开源项目维护者可以直接往中央仓库push代码，而代码贡献者只能将代码push到自己的私有仓库，只有项目维护者接受代码贡献者往中央仓库发起的pull request才会真正合入。</p>
<p><strong>小结一下</strong></p>
<p>上面已经大致讲了在git当中的四种比较常见的工作流，都是需要开发者去实践理解的。</p>
<p>关于git工作流，只有选用最合适自己团队的工作流才能有效的提高开发效率，上面提到的一些工作流模式都有各自的适用场景，如何选用适合自己团队的工作流得结合团队成员的实际情况，看团队成员对于工作流的理解程度，还有对于工作流的执行程度。</p>
<h2 id="我们团队的一些实践"><a href="#我们团队的一些实践" class="headerlink" title="我们团队的一些实践"></a>我们团队的一些实践</h2><p>现在讲下我们团队针对Gitflow的一些实践：</p>
<p><strong>master分支</strong></p>
<ul>
<li>主分支</li>
<li>保持稳定</li>
<li>不允许直接往这个分支提交代码，只允许往这个分支发起merge request</li>
<li>只允许release分支和hotfix分支进行合流</li>
</ul>
<p><strong>develop分支</strong></p>
<ul>
<li>开发分支</li>
<li>相对稳定的分支</li>
<li>用于日常开发，包括代码优化、功能性开发</li>
</ul>
<p><strong>feature分支</strong></p>
<ul>
<li>特性分支</li>
<li>从develop分支拉取，用于下个迭代版本的功能特性开发</li>
<li>功能开发完毕合并到develop分支</li>
</ul>
<p><strong>release分支</strong></p>
<ul>
<li>发布分支</li>
<li>从develop分支拉取</li>
<li>用于回归测试，bug修复</li>
<li>发布完成后打tag并合入master和develop</li>
</ul>
<p><strong>hotfix分支</strong></p>
<ul>
<li>热更新分支</li>
<li>从develop分支拉取</li>
<li>用于紧急修复上线版本的问题</li>
<li>修复后打tag并合入master和develop</li>
</ul>
<p>大家可能会发现我们这个跟标准的Gitflow工作流有些差别，其实也没有什么标准不标准的，前面说到要结合团队的实际情况，我们团队对于目前所采用的工作方式都是达成共识的，所以有一些差异并没有关系。</p>
<p>说了这么久，还没有一句git命令，那就让大家感受一下吧（感谢Bugly小色熊整理）：</p>
<p> 1). 首先将远程代码拉取到本地</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git clone xxx</div><div class="line">git checkout -b develop origin/develop</div></pre></td></tr></table></figure>
<p> 2).新建feature分支</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git checkout -b feature</div></pre></td></tr></table></figure>
<p> 3).多人在feature上开发，如果中途需要将develop的变更合入feature，所有人需要将本地的代码变更提交到远程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git fetch origin </div><div class="line">git rebase origin/feature</div><div class="line">git push origin feature</div></pre></td></tr></table></figure>
<p> 然后由feature负责人rebase develop分支，删除原来feature分支，重新新建feature分支；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">git fetch origin</div><div class="line">git rebase origin/feature</div><div class="line">git rebase develop</div><div class="line">git push origin :feature</div><div class="line">git push origin feature</div></pre></td></tr></table></figure>
<p> 这样可以保证feature保持线性变更；</p>
<p> 4).feature开发完成后，所有人需要将本地的代码变更提交到远程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git fetch origin </div><div class="line">git rebase origin/feature</div><div class="line">git push origin feature</div></pre></td></tr></table></figure>
<p> 然后由feature负责人rebase develop分支，然后将feature分支合入develop，删除feature；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">git fetch origin</div><div class="line">git rebase origin/feature</div><div class="line">git rebase develop</div><div class="line">git checkout develop</div><div class="line">git merge feature</div><div class="line">git push origin :feature</div></pre></td></tr></table></figure>
<p> 这样可以保证develop保持线性变更，各feature的变更完整可追溯；<br> 5).合入feature后拉出对应的release/feature分支，后续bug修复在release/feature上</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git checkout develop</div><div class="line">git checkout -b release/feature</div></pre></td></tr></table></figure>
<p> release/feature分支的同步合并与feature分支相同<br> 6).release/feature分支bug修复完成后，拉取对应的tag推送远程进行发布</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git tag -a v1.0 -m &apos;feature发布&apos;</div><div class="line">git push origin v1.0</div></pre></td></tr></table></figure>
<p> 之后将release/feature合入develop分支，然后删除</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">git rebase develop</div><div class="line">git checkout develop</div><div class="line">git merge release/feature</div><div class="line">git push origin :release/feature</div></pre></td></tr></table></figure>
<p> 7).发布完成后将release合入master分支，保证master为最新稳定版本（实际操作为发起merge request）</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇文章主要针对笔者工作中对于git工作流的一些理解和实践，目前我们团队也是严格按照这样的工作流来完成日常的开发工作，一个让团队成员认可并且有效的工作流才是最适合我们的工作流，任何规则不是为了限制我们思考，而是为了让工作更加高效有序，尽量减少人为的失误。git是一个博大精深的东西，笔者也是不断在实际应用中去理解它，任何一门技术的学习也是这样，就像程序员常用来装逼的一首诗：</p>
<blockquote>
<p>纸上得来终觉浅，绝知此事要躬行。</p>
</blockquote>
<p>参考资料：<a href="http://blog.jobbole.com/76847/" target="_blank" rel="external">http://blog.jobbole.com/76847/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;笔者使用git有一段时间了，踩过不少坑，这里分享下我在git工作流方面的一些经验。&lt;/p&gt;
&lt;h2 id=&quot;什么是Git工作流？&quot;&gt;&lt;a href=&quot;#什么是Git工作流？&quot; class=&quot;headerlink&quot; title=&quot;什么是Git工作流？&quot;&gt;&lt;/a&gt;什么是Git工
    
    </summary>
    
      <category term="经验分享" scheme="https://buglydevteam.github.io/categories/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="Git" scheme="https://buglydevteam.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Bugly热更新SDK你需要知道的一些事</title>
    <link href="https://buglydevteam.github.io/2016/11/28/bugly-android-hotfix-you-should-know/"/>
    <id>https://buglydevteam.github.io/2016/11/28/bugly-android-hotfix-you-should-know/</id>
    <published>2016-11-28T05:19:58.000Z</published>
    <updated>2016-12-03T11:50:01.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Bugly出热更新SDK了？"><a href="#Bugly出热更新SDK了？" class="headerlink" title="Bugly出热更新SDK了？"></a>Bugly出热更新SDK了？</h2><p>没错，Bugly也出热更新SDK啦，2016.11.25号，我们Bugly也上线了Android版的热更新SDK，大家都知道这一年来<strong>热更新</strong>被无数次提起，各大厂自主研发的热更新方案层出不穷，下面就列举一些大家比较熟悉的一些热更新方案：</p>
<p>微信开源：<a href="https://github.com/Tencent/tinker" target="_blank" rel="external">Tinker</a><br>大众点评：<a href="https://github.com/jasonross/Nuwa" target="_blank" rel="external">Nuwa</a><br>阿里巴巴：<a href="https://github.com/alibaba/dexposed" target="_blank" rel="external">Dexposed</a><br>阿里巴巴：<a href="https://github.com/alibaba/AndFix" target="_blank" rel="external">AndFix</a><br>美团：<a href="http://tech.meituan.com/android_robust.html" target="_blank" rel="external">Robust</a></p>
<p>各个方案的优劣性笔者就不在这里做过多讨论了，总的一句话<strong>没有最好的，只有最适合自己的</strong>。</p>
<p><strong>我们Bugly也是出于高可用性的考虑，Tinker支持动态下发代码、So库以及资源，所以我们最终选择了Tinker方案作为我们SDK的一项能力。</strong></p>
<p>这里有一点需要说明的，<strong>Android版的热更新SDK是包含在升级SDK里面的</strong>，所以如果你想使用我们提供的热更新能力需要下载对应版本的<a href="https://bugly.qq.com/v2/sdkDownload" target="_blank" rel="external">升级SDK</a>，目前我们在1.2.0版本才开始支持热更新：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/2016-11-28/hotfix-0.png" alt="热更新SDK" title="">
                </div>
                <div class="image-caption">热更新SDK</div>
            </figure>
<font color="red">注意：升级SDK自1.2.0起将不再支持以jar包形式集成，我们建议您使用Android studio并且以gradle方式集成。</font>

<h2 id="为什么集成我们Bugly热更新SDK？"><a href="#为什么集成我们Bugly热更新SDK？" class="headerlink" title="为什么集成我们Bugly热更新SDK？"></a>为什么集成我们Bugly热更新SDK？</h2><p>热更新能力是Bugly为解决开发者紧急修复线上Bug，而无需重新发版让用户无感知就能把问题修复的一项能力。Bugly目前采用<a href="https://github.com/Tencent/tinker" target="_blank" rel="external">微信Tinker</a>的开源方案，开发者只需要集成我们提供的SDK就可以实现<strong>自动下载补丁包、合成、并且应用补丁的功能</strong>，我们也提供了<strong>热更新管理后台</strong>让开发者对每个版本的补丁进行管理。</p>
<p>集成我们SDK的好处是显而易见的：</p>
<ul>
<li>无需关注Tinker是如何合成补丁的</li>
<li>无需自己搭建补丁管理后台</li>
<li>无需考虑后台下发补丁策略的任何事情</li>
<li>无需考虑补丁下载合成的时机，处理后台下发的策略</li>
<li>我们提供了更加方便集成Tinker的方式</li>
<li>我们提供应用升级一站式解决方案</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/2016-11-28/hotfix-1.png" alt="应用升级" title="">
                </div>
                <div class="image-caption">应用升级</div>
            </figure>
<h2 id="如何集成Bugly热更新SDK？"><a href="#如何集成Bugly热更新SDK？" class="headerlink" title="如何集成Bugly热更新SDK？"></a>如何集成Bugly热更新SDK？</h2><blockquote>
<p>看文档、看文档、看文档。重要的事情说三遍。<br><a href="https://bugly.qq.com/docs/user-guide/instruction-manual-android-hotfix/" target="_blank" rel="external">Android热更新接入指南</a></p>
</blockquote>
<p>相信接入过Tinker的同学会发现使用Tinker还是有一定门槛的，小白用户第一次使用可能会懵圈，我们Bugly也希望能让第一次接入的同学能顺利使用上热更新，所以建议大家严格按照我们文档的流程来接入，如果遇到任何使用SDK的问题可以及时跟我们反馈（交流群号：130979883），但如果是Tinker插件的使用问题也是建议您认真查看<a href="https://github.com/Tencent/tinker/wiki" target="_blank" rel="external">Tinker Wiki</a>。</p>
<p>简单概要说一下整个接入流程：</p>
<ol>
<li>配置插件依赖（这里包含<strong>tinker插件</strong>和<strong>tinker-support插件</strong>的依赖）</li>
<li>apply插件（这里可以只配置<code>apply plugin: &#39;com.tencent.bugly.tinker-support&#39;</code>）</li>
<li><p>集成SDK</p>
<ul>
<li>集成远程SDK仓库</li>
<li>重新自定义Application、ApplicationLike</li>
<li>AndroidManifest配置</li>
<li>混淆配置</li>
</ul>
</li>
<li><p>测试验证</p>
<ul>
<li>打基准包安装并上报联网（注：填写唯一的tinkerId）</li>
<li>对基准包的bug修复（可以是Java代码变更，资源的变更）</li>
<li>修改基准包路径、填写补丁包tinkerId、mapping文件路径、resId文件路径</li>
<li>执行tinkerPatchRelease打Release版本补丁包</li>
<li>选择app/build/outputs/patch目录下的补丁包并上传（注：不要选择tinkerPatch目录下的补丁包，不然上传会有问题）</li>
<li>编辑下发补丁规则，点击<strong>立即下发</strong></li>
<li>重启基准包，请求补丁策略（SDK会自动下载补丁并合成）</li>
<li>再次重启基准包，检验补丁应用结果</li>
</ul>
</li>
</ol>
<p>以上是应用补丁的流程，有同学可能会问，如果我想撤回怎么办？这里先解释下我们补丁的几种状态：</p>
<ul>
<li>下发中</li>
<li>生效中、下发停止</li>
<li>撤回中</li>
</ul>
<p><strong>下发中</strong>：表示你上传一个补丁后，点击立即下发之后的状态，表示后台正在下发补丁策略，补丁包对应的基线版本是可以收到对应的策略的。</p>
<p><strong>生效中、下发停止</strong>：表示你已经下发过这个补丁，但因为你上传了新补丁，这个补丁下发会被停止，要注意一个目标版本只运行下发一个补丁。</p>
<p><strong>撤回中</strong>：表示你不再下发这个补丁，这个操作是不可逆的，点击撤回，基线版本将不会再收到这个补丁策略。</p>
<p><img src="/images/2016-11-28/hotfix-2.png" alt="补丁状态"></p>
<p>以上就是Bugly热更新SDK的集成方式一些说明啦，如果还有疑问直接找Bugly-kirito咨询。</p>
<h2 id="一些大家比较关注的问题"><a href="#一些大家比较关注的问题" class="headerlink" title="一些大家比较关注的问题"></a>一些大家比较关注的问题</h2><p><strong>Q：Bugly热更新会收费么？</strong></p>
<p>A：大家可以放心，我们热更新服务目前是完全免费的。</p>
<p><strong>Q：之前使用Tinker，怎么切换过来使用Bugly？</strong></p>
<p>A： 你只需在dependencies中配置一句代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">compile &quot;com.tencent.bugly:crashreport_upgrade:1.2.0&quot;</div></pre></td></tr></table></figure>
<p>注释掉以前的配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 可选，用于生成application类 </div><div class="line">   //provided(&apos;com.tencent.tinker:tinker-android-anno:1.7.5&apos;)</div><div class="line">   // tinker的核心库</div><div class="line">   // compile(&apos;com.tencent.tinker:tinker-android-lib:1.7.5&apos;)</div></pre></td></tr></table></figure>
<p>插件配置不需要更改，只需要加上我们Bugly额外的tinker-support插件即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// tinker gradle插件</div><div class="line">   classpath (&apos;com.tencent.tinker:tinker-patch-gradle-plugin:1.7.5&apos;)</div><div class="line"></div><div class="line">   // tinkersupport插件</div><div class="line">   classpath &quot;com.tencent.bugly:tinker-support:1.0.1&quot;</div></pre></td></tr></table></figure>
<p>这里建议您不要随便更改插件版本，避免因为插件的更新导致您无法正常生成我们需要的补丁包。</p>
<p><strong>Q：如果我配置了升级策略，又配置了补丁策略，会是怎样的效果？</strong></p>
<p>A：升级策略优先级会高于补丁策略，后台会优先下发升级策略。毕竟你都要升级了，热更新只是帮助你修复bug而已。</p>
<p><strong>Q：我只想使用热更新，不想使用升级？</strong></p>
<p>A：热更新是包含在升级SDK里面的，你可以不配置任何升级策略，只需按照热更新文档集成即可。</p>
<p><strong>Q：是否支持加固模式？</strong></p>
<p>A：tinker是支持加固模式的，但需要你回退到Qzone方案<br>，将<code>usePreGeneratedPatchDex</code>设置为true。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/2016-11-28/hotfix-3.png" alt="Alt" title="">
                </div>
                <div class="image-caption">Alt</div>
            </figure>
<p>但要注意Tinker官方的提示：</p>
<blockquote>
<p>是否提前生成dex，而非合成的方式。这套方案即回退成Qzone的方案，对于需要使用<strong>加固或者多flavor打包(建议使用其他方式生成渠道包)的用户可使用</strong>。但是这套方案需要插桩，会造成<strong>Dalvik下性能损耗以及Art补丁包可能过大的问题，务必谨慎使用</strong>。另外一方面，这种方案在Android N之后可能会产生问题，建议过滤N之后的用户。</p>
</blockquote>
<p><strong>Q：是否支持打多Flavor的patch包</strong><br>A：支持的。你需要配置productFlavor（示例）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">productFlavors &#123;</div><div class="line">      xiaomi &#123;</div><div class="line">          applicationId &apos;com.tencent.bugly.hotfix.xiaomi&apos;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      yyb &#123;</div><div class="line">          applicationId &apos;com.tencent.bugly.hotfix.yyb&apos;</div><div class="line">      &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>打flavor包，只需要配置构建flavor的目录，其他字段不需要填写（执行tinkerPatchAllFalvorRelease就可以得到所有flavor的包）：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/2016-11-28/hotfix-4.png" alt="flavor路径配置" title="">
                </div>
                <div class="image-caption">flavor路径配置</div>
            </figure>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/2016-11-28/hotfix-5.png" alt="打flavor的Task" title="">
                </div>
                <div class="image-caption">打flavor的Task</div>
            </figure>
<h2 id="总结-amp-展望"><a href="#总结-amp-展望" class="headerlink" title="总结&amp;展望"></a>总结&amp;展望</h2><p>关于Bugly热更新SDK你需要知道的一些事情，笔者已经讲完啦，如果你在使用过程中遇到任何问题可以及时跟我们反馈，我们会持续跟进优化SDK和完善接入流程，后续我们会分享更多我们Bugly关于热更新的一些技术和原理上的理解，希望本篇文章能够让使用Bugly热更新SDK的同学和想了解我们热更新的同学的有一些解惑。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Bugly出热更新SDK了？&quot;&gt;&lt;a href=&quot;#Bugly出热更新SDK了？&quot; class=&quot;headerlink&quot; title=&quot;Bugly出热更新SDK了？&quot;&gt;&lt;/a&gt;Bugly出热更新SDK了？&lt;/h2&gt;&lt;p&gt;没错，Bugly也出热更新SDK啦，2016
    
    </summary>
    
      <category term="Android" scheme="https://buglydevteam.github.io/categories/Android/"/>
    
    
      <category term="热更新" scheme="https://buglydevteam.github.io/tags/%E7%83%AD%E6%9B%B4%E6%96%B0/"/>
    
      <category term="Bugly" scheme="https://buglydevteam.github.io/tags/Bugly/"/>
    
      <category term="Tinker" scheme="https://buglydevteam.github.io/tags/Tinker/"/>
    
  </entry>
  
</feed>
